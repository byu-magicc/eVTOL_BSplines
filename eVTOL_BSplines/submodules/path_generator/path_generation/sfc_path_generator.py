#this file re implements the Path Generator's stuff, but this time rewritten to make more sense
#and to be a greater deal of optimality.

import os, sys
import numpy as np
from scipy.optimize import minimize, Bounds, LinearConstraint, NonlinearConstraint, Bounds
from path_generation.matrix_evaluation import get_M_matrix, evaluate_point_on_interval
from PathObjectivesAndConstraints.python_wrappers.objective_functions import ObjectiveFunctions
from PathObjectivesAndConstraints.python_wrappers.curvature_constraints import CurvatureConstraints
from PathObjectivesAndConstraints.python_wrappers.obstacle_constraints import ObstacleConstraints
from PathObjectivesAndConstraints.python_wrappers.incline_constraints import InclineConstraints
from PathObjectivesAndConstraints.python_wrappers.waypoint_constraints import WaypointConstraints
from bsplinegenerator.bspline_to_minvo import get_composite_bspline_to_minvo_conversion_matrix
from path_generation.safe_flight_corridor import SFC_Data, SFC
from path_generation.obstacle import Obstacle
from path_generation.waypoint_data import Waypoint, WaypointData
from eVTOL_BSplines.message_types.msg_control_points import MSG_Control_Points
from eVTOL_BSplines.message_types.msg_annulus_convex_hull import Msg_Annulus_Convex_Hull
import time
import cProfile
import pstats
from copy import deepcopy
from bsplinegenerator.bspline_to_minvo import convert_list_to_minvo_control_points
from path_generation.sfc_path_generator_helpers import *

import cvxpy as cp

class SFC_PathGenerator:


    #creates the initialization function.
    def __init__(self,
                 num_intervals_free_space: int = 5):
        #sets the dimension to two for now
        self._dimension = 2
        #sets the number of intervals free space
        self.num_intervals_free_space = num_intervals_free_space
        #I'm only dealing with 3rd degree bsplines (called order in his stuff. I know - it's annoying)
        self._order = 3
        #gets the Minvo conversion matrix
        self._Minvo_matrix = get_M_matrix(order=self._order)
        #gets the objective functions from the c files
        self._objective_func_obj = ObjectiveFunctions(self._dimension)
        self._curvature_const_obj = CurvatureConstraints(self._dimension)
        self._waypoint_const_obj = WaypointConstraints(self._dimension)
        self._obstacle_cons_obj = ObstacleConstraints(self._dimension)


    #defines the function to generate the path using control points
    def generatePath(self,
                     M: int,
                     startControlPoints: np.ndarray,
                     endControlPoints: np.ndarray,
                     sfc_data: SFC_Data,
                     numPointsPerUnit: float,
                     objectiveFunctionType: str,
                     annulusConvexHulls_list: list[Msg_Annulus_Convex_Hull] = None,
                     overlappingConstraints: bool = True,
                     nonConvexConstraints: bool = False):
        

        #calls the function to get the list of lengths
        numCntPts_list = getNumCntPts_list(sfc_data=sfc_data,
                                           numPointsPerUnit=numPointsPerUnit)
        
        startTime = time.time()
        optimizedControlPoints_convex \
              = self.generatePath_convex(numCntPts_list=numCntPts_list,
                                         startControlPoints=startControlPoints,
                                         endControlPoints=endControlPoints,
                                         sfc_data=sfc_data,
                                         objectiveFunctionType=objectiveFunctionType,
                                         annulusConvexHulls_list=annulusConvexHulls_list,
                                         overlappingConstraints=overlappingConstraints)
        
        endTime = time.time()
        totalTime = endTime - startTime
        
        #case we are dealing with 
        if nonConvexConstraints:

            outputControlPoints = self.generatePath_nonConvexConstraints()
        else:
            outputControlPoints = optimizedControlPoints_convex


        #returns the output control points
        return outputControlPoints

        



    #defines the function to use the existing control points generated by the
    #CVXPY Method, and then optimizes them for curvature and other non-convex 
    #constraints and so forth
    def generatePath_nonConvexConstraints(self,
                                          numCntPts_list: list[int],
                                          startControlPoints: np.ndarray,
                                          endControlPoints: np.ndarray,
                                          max_curvature: np.float64 = None,
                                          sfc_data: SFC_Data = None,
                                          ):

        potato = 0

    #defines the function go solve for the control points using convex cvxpy methods
    def generatePath_convex(self,
                            numCntPts_list: list[int],
                            startControlPoints: np.ndarray,
                            endControlPoints: np.ndarray,
                            sfc_data: SFC_Data,
                            objectiveFunctionType: str = 'minimize_distance',
                            annulusConvexHulls_list: list[Msg_Annulus_Convex_Hull] = None,
                            overlappingConstraints=True):
        
        profiler = cProfile.Profile()
        profiler.enable()
        
        startControlPoints, endControlPoints\
              = getShortenedControlPoints(startControlPoints=startControlPoints,
                                          endControlPoints=endControlPoints)
        
        #gets the sfc list
        sfc_list = sfc_data.get_sfc_list()


        #gets the number of control points
        numControlPoints = getNumCntPts(numCntPts_list=numCntPts_list,
                                        degree = self._order)


        #creates the control points variable
        controlPoints_cpVar = cp.Variable((2, numControlPoints))

        #gets the control points constraints

        #case overlapping Constraints (where the overlapping control points need to meet both requirements)
        if overlappingConstraints:
            controlPoints_constraints \
                = self.get_overlapping_control_points_constraints(sfc_data=sfc_data,
                                                                  numCntPts_list=numCntPts_list,
                                                                  numControlPoints=numControlPoints,
                                                                  controlPoints_var=controlPoints_cpVar,
                                                                  annulusConvexHulls_list=annulusConvexHulls_list,
                                                                  startControlPoints=startControlPoints,
                                                                  endControlPoints=endControlPoints)
        #case non overlapping constraints, where the overlapping control points only are in one constraint
        else:
            controlPoints_constraints \
                = self.get_singular_control_points_constraints(sfc_data=sfc_data,
                                                               numCntPts_list=numCntPts_list,
                                                               controlPoints_var=controlPoints_cpVar,
                                                               startControlPoints=startControlPoints,
                                                               endControlPoints=endControlPoints)
            
        
        #case min distance objective function
        if objectiveFunctionType == 'minimize_distance':

            #gets the minimize length objective function
            objectiveFunction = self.minimum_distance_objective(cpVar_cntPts=controlPoints_cpVar)
        elif objectiveFunctionType == 'minimize_acceleration':
            #gets  the minimize acceleration objective function
            objectiveFunction = self.minimum_acceleration_objective(cpVar_cntPts=controlPoints_cpVar)



        #TODO remove this section, which is used only for testing purposes
        totalFeasibilityProblem = cp.Problem(objective=cp.Minimize(0),
                                             constraints=controlPoints_constraints)
        
        totalFeasibilityProblem.solve(solver=cp.CLARABEL,
                                      verbose=False)

        ########################################################################
        #actual solving section. 
        #creates the problem to solve
        problem = cp.Problem(objective=objectiveFunction,
                             constraints=controlPoints_constraints)
        
        #calls the solve function for the problem
        problem.solve(solver=cp.CLARABEL)



        #gets the output control points
        outputControlPoints = controlPoints_cpVar.value


        profiler.disable()

        stats = pstats.Stats(profiler)
        #stats.strip_dirs().sort_stats("cumulative").print_stats(40)


        return outputControlPoints


    #creates the function to define the objective function
    def minimum_distance_objective(self, cpVar_cntPts: cp.Variable):
        #gets the velocity control poitns
        velocityControlPoints_cp = cpVar_cntPts[:,0:-1] - cpVar_cntPts[:,1:]

        minimizeLength_objectiveFunction = cp.Minimize(cp.sum(cp.norm(velocityControlPoints_cp, axis=1)))

        #returns the objective
        return minimizeLength_objectiveFunction

    #creates the function to get the minimum acceleration objective function
    def minimum_acceleration_objective(self, cpVar_cntPts: cp.Variable):
        #gets the jerk control points
        jerkCntPts_cp = cpVar_cntPts[:,3:] -3*cpVar_cntPts[:,2:-1] + 3*cpVar_cntPts[:,1:-2] - cpVar_cntPts[:,0:-3]
        #gets the objective
        objective = cp.Minimize(cp.sum(cp.norm(jerkCntPts_cp, axis=1)))
        #returns the objective
        return objective

    #creates the function to get singlar control points constraints
    #This one is actually Bad. The spline constantly cuts corners.
    def get_singular_control_points_constraints(self,
                                                sfc_data: SFC_Data,
                                                numCntPts_list: list[int],
                                                controlPoints_var: cp.Variable,
                                                startControlPoints: np.ndarray,
                                                endControlPoints: np.ndarray):
        

        #gets the sfc list
        sfc_list = sfc_data.get_sfc_list()

        #creates the constraints 
        controlPoints_constraints = []

        #creates the index
        index = 0

        for i, sfc in enumerate(sfc_list):

            #gets the number of control points

            #checks if we are in the first corridor. if we are, then we
            #apply the constraints on all the control points in this one
            if i == 0:
                numControlPoints_perConstraint = numCntPts_list[i]
            #otherwise the number of control points per constraint is M
            else:
                numControlPoints_perConstraint = numCntPts_list[i] - self._order
            #gets the partition of the control points variable
            controlPointsPartition = controlPoints_var[:,index:(index+numControlPoints_perConstraint)]

            #gets the normals and the vertices
            normals, vertices = sfc.getNormalsVertices_2d()

            #gets the A and b matrix
            A, b = generate_A_b(normalVectors=normals,
                                vertices=vertices)

            #creates the inequality constraint
            inequalityConstraint_temp = [A @ controlPointsPartition <= b]

            #adds to the constraints
            controlPoints_constraints += inequalityConstraint_temp

            #adds the number of control points to the index
            index += numControlPoints_perConstraint

        #gets the start control points variables
        startControlPoints_cpVar = controlPoints_var[:, :self._order]
        endControlPoints_cpVar = controlPoints_var[:, (-self._order):]

        startEqualityConstraint = [startControlPoints_cpVar == startControlPoints]
        endEqualityConstraint = [endControlPoints_cpVar == endControlPoints]

        #adds those in
        controlPoints_constraints += startEqualityConstraint
        controlPoints_constraints += endEqualityConstraint

        #returns the constraints
        return controlPoints_constraints


    #creates the function for overlapping control points constraints
    def get_overlapping_control_points_constraints(self,
                                                sfc_data: SFC_Data,
                                                numCntPts_list: list[int],
                                                numControlPoints: int,
                                                controlPoints_var: cp.Variable,
                                                annulusConvexHulls_list: list[Msg_Annulus_Convex_Hull],
                                                startControlPoints: np.ndarray,
                                                endControlPoints: np.ndarray):
        totalStartTime = time.time()
        #gets the sfc list
        sfc_list = sfc_data.get_sfc_list()

        #creates the control poitns index
        controlPoints_index = 0 

        #creates the list of conditions
        controlPoints_constraints = []

        #creates the list of lists for the A matrices for each control point
        A_matrices_SFC_list = []
        #does the same for the b vectors
        b_vectors_sfc_list = []

        A_matrices_complete = []

        b_vectors_complete = []

        #General SFC constraints section
        #iterates over each safe flight corridor in the sfc list
        for i, sfc in enumerate(sfc_list):

            #gets the number of control points in the current corridor
            numCntPoints_inCorridor = numCntPts_list[i]

            #gets the incremental index
            incremental_index = numCntPoints_inCorridor - self._order

            #gets the current control points partition
            controlPointsPartition \
                  = controlPoints_var[:,(controlPoints_index):(controlPoints_index+numCntPoints_inCorridor)]

            #gets the normals and vertices
            normals, vertices = sfc.getNormalsVertices_2d()

            #gets the A and b matrices
            A, b = generate_A_b(normalVectors=normals,
                                vertices=vertices)
            

            for i in range(numCntPoints_inCorridor):
                #current index
                currentIndex = controlPoints_index + i

                #checks if the index currently exists in the A list
                if currentIndex < len(A_matrices_complete):
                    #then we can add to it
                    #gets the current A and b lists
                    A_matrices_complete[currentIndex].append(A)
                    b_vectors_complete[currentIndex].append(b)
                #otherwise we create it
                else:
                    A_matrices_complete.append([A])
                    b_vectors_complete.append([b])
            
            A_matrices_SFC_list.append(A)
            b_vectors_sfc_list.append(b)

            #appends the A and b matrices to the respective sections in the list
            
            #gets the temp inequality constraint
            inequalityConstraint_temp = [A @ controlPointsPartition <= b]

            #adds this to the constraints
            controlPoints_constraints += inequalityConstraint_temp

            #increments the control points index by the incremental amount
            controlPoints_index += incremental_index

        #if the annulus list is not none. if it is, we do not create the annulus
        if annulusConvexHulls_list is not None:
            #calls the function to get the annulus constraints
            annulusConstraintsList = self.get_annulus_constraints(annulus_list=annulusConvexHulls_list,
                                                                  controlPoints_var=controlPoints_var,
                                                                  numCntPts_list=numCntPts_list)
            
            #adds the annulus constraints list to main list
            controlPoints_constraints += annulusConstraintsList
    
            #gets the annulus matrices
            A_annulus, b_annulus, indices_annulus = self.get_annulus_AbIndices()
    
            #iterates over each of the control points in the list
            for i, index in enumerate(indices_annulus):
                current_A = A_annulus[i]
                current_b = b_annulus[i]
    
                A_matrices_complete[index].append(current_A)
                b_vectors_complete[index].append(current_b)
        

        #creates the concatenated A and b matrices
        self.A_cat_list = []

        self.b_cat_list = []

        for A_list, b_list in zip(A_matrices_complete, b_vectors_complete):

            A = np.ndarray((0,2))
            b = np.ndarray((0,1))
            #iterates over the items here
            for A_temp, b_temp in zip(A_list, b_list):
                A = np.concatenate((A, A_temp), axis=0)
                b = np.concatenate((b, b_temp), axis=0)

            #adds this A and b to the full list
            self.A_cat_list.append(A)
            self.b_cat_list.append(b)


        #gets the varaibles corresponding to the start and end control points
        startControlPoints_cpVar = controlPoints_var[:, :self._order]
        endControlPoints_cpVar = controlPoints_var[:, (-self._order):]


        #creates the equality constraints for start and end conditions
        startEqualityConstraint = [startControlPoints_cpVar == startControlPoints]
        endEqualityConstraint = [endControlPoints_cpVar == endControlPoints]

        #adds these equality constraints to the main constraints list
        controlPoints_constraints += startEqualityConstraint
        controlPoints_constraints += endEqualityConstraint

        totalEndTime = time.time()
        totalTime = totalEndTime - totalStartTime

        #returns the constraints list
        return controlPoints_constraints

    #defines the function to get the convex hull from the annulus
    #arguments:
    #annulus_list: the list of annulus convex hull messages
    #controlPoints_var: the cp variable from which we will extract our information
    #constrainedPoints_list: the list of the indices of each of the control points which correspond to each of the hulls
    #                        to which they are constrained
    def get_annulus_constraints(self,
                                annulus_list: list[Msg_Annulus_Convex_Hull],
                                controlPoints_var: cp.Variable,
                                numCntPts_list: list[int]):
        
        degree = self._order

        #creates the control poitns constraints list
        controlPointsConstraints_list = []

        #creates the A, b, and absolute indices list
        self.A_annulus_list = []
        self.b_annulus_list = []
        self.absolute_indices_list = []

        #iterates ov er the annulus list
        for i, msg_annulus in enumerate(annulus_list):

            #gets the temp annulus num ctrl pts
            temp_annulus_numPts = msg_annulus.getNumPts()

            #gets the normals list
            allNormalsList = msg_annulus.allNormalsList
            allVerticesList = msg_annulus.allVerticesList

            #gets the number of control poitns in the SFC
            numCntPts_SFC_temp = numCntPts_list[i]

            #gets the lower control point index
            lowerIndex_local = getLowerIndex(numCntPts_SFC=numCntPts_SFC_temp,
                                             numCntPts_Annulus=temp_annulus_numPts,
                                             d=degree)
            
            #gets the upper Index
            upperIndex_local = getUpperIndex(numCntPts_Annulus=temp_annulus_numPts,
                                             d=degree)
            
            #gets the absolute lower and upper indices
            lowerIndex_absolute = getAbsoluteIndex(numCntPts_list=numCntPts_list,
                                                   sfc_index=i,
                                                   controlPoint_index=lowerIndex_local,
                                                   degree=degree)

            upperIndex_absolute = getAbsoluteIndex(numCntPts_list=numCntPts_list,
                                                   sfc_index=(i+1),
                                                   controlPoint_index=upperIndex_local,
                                                   degree=degree)
            
            #Now that we are armed with the information about the lower and upper absolute indices, we would like to individually go through 
            #each of the control points, and generate the container for each of the control points in the mix
            for i, (tempNormalList, tempVerticesList) in enumerate(zip(allNormalsList, allVerticesList)):
                #gets the current index of the current control point
                currentControlPointIndex_absolute = lowerIndex_absolute + i

                #gets the current control point partition
                controlPoints_partition = controlPoints_var[:,currentControlPointIndex_absolute:(currentControlPointIndex_absolute+1)]

                #gets the A and b matrices
                A, b = generate_A_b(normalVectors=tempNormalList,
                                    vertices=tempVerticesList)
                
                self.A_annulus_list.append(A)
                self.b_annulus_list.append(b)
                self.absolute_indices_list.append(currentControlPointIndex_absolute)

                #creates the temp inequality constraint
                temp_inequality_constraint = [A @ controlPoints_partition <= b]


                #adds this constraint to the list
                controlPointsConstraints_list += temp_inequality_constraint


        return controlPointsConstraints_list
    
    #gets the annulus A, b, and indices
    def get_annulus_AbIndices(self):
        return self.A_annulus_list, self.b_annulus_list, self.absolute_indices_list
        
    
    #defines the function to obtain the scipy control points for the Non-Convex
    #post processing optimization, which yields some cleaner results with less curvature
    def get_control_points_constraints_scipy(self,
                                             max_curvature: float,
                                             sfc_data: SFC_Data,
                                             numCntPts_list: list[int],
                                             startControlPoints: np.ndarray,
                                             endControlPoints: np.ndarray):
    
        #gets the list of constraints
        constraints = []

        #gets the sfc constraints
        sfc_constraints = self.get_constraints_sfc_scipy(sfc_data=sfc_data)
        constraints.append(sfc_constraints)



        return 0
    

    #gets the sfc constraints for scipy
    def get_constraints_sfc_scipy(self,
                                  sfc_data: SFC_Data):
        sfc_list = sfc_data.get_sfc_list()

        #creates the linear constriants list
        linearConstraint_list = []

        #gets the linear constraints 
        for sfc in sfc_list:

            #gets the normals and the vertices
            normals, vertices = sfc.getNormalsVertices_2d()

            #gets the A and b matrices corresponding to those two
            A, b = generate_A_b(normalVectors=normals,
                                vertices=vertices)
            
            #gets the linear constraint corresponding to the A, and b vectors
            tempConstraint = LinearConstraint(A=A,
                                              ub=b)
            
            #appends the constraint to the linear constraints list
            linearConstraint_list.append(tempConstraint)


        #returns the linear constraint list
        return linearConstraint_list


    #gets the start and stop constraints for scipy
    def get_constraints_init_final_scipy(self,
                                   numCntPts_list: list[int],
                                   startControlPoints: np.ndarray,
                                   endControlPoints: np.ndarray):
        
        #gets the A matrix
        dimension = np.shape(startControlPoints)[0]
        numStartControlPoints = np.shape(startControlPoints)[1]
        numEndControlPoints = np.shape(endControlPoints)[1]

        A_length = dimension * numStartControlPoints

        #creates the start A matrix
        A_start = np.eye(N=A_length)

        #creates the end A matrix
        A_end = np.eye(N=A_length)

        #gets the start contorl points stacked
        startControlPoints_stacked = stackMatrix(controlPoints=startControlPoints)
        endControlPoints_stacked = stackMatrix(controlPoints=endControlPoints)

        #creates the constraints list
        equalityConstraints = []

        equalityConstraints.append(startControlPoints)

    #gets the A and b cat list
    def getAb_cat_list(self):
        return self.A_cat_list, self.b_cat_list
    




#defines the function to get the absolute index of the control points, given the indexing list
def getAbsoluteIndex(numCntPts_list: list[int],
                     sfc_index: int,
                     controlPoint_index: int,
                     degree: int):
    
    tempSum = 0
    #iterates to get the previous sum
    for i in range(sfc_index):
        tempSum += (numCntPts_list[i] - degree)

    #adds the temp sum to the contorl point index
    tempSum += controlPoint_index

    return tempSum

#defines to get the SFC indices from the control point absolute index
def getSFCIndices_absoluteIndex(controlPoint_absoluteIndex: int,
                                sfcLengths_list: list[int],
                                degree: int):

    #gets the number of corridors
    numCorridors = len(sfcLengths_list)

    sum = 0

    for i, sfc_length in enumerate(sfcLengths_list):
        
        #case we are on the zeroth one
        if i == 0:

            #case we are in the start or center portion
            if sum <= controlPoint_absoluteIndex < (sum + sfc_length - degree):
                sfc_indices = [i]
                return sfc_indices
            #case we are in the overlap
            elif (sum + sfc_length - degree) <= controlPoint_absoluteIndex < (sum + sfc_length):
                #then we return two
                sfc_indices = [i, i+1]
                return sfc_indices
        
        #case we are in the middle ones
        elif 0 < i < (numCorridors - 1):

            #case we are in the beginning overlap section
            if sum <= controlPoint_absoluteIndex < (sum + degree):
                sfc_indices = [i-1, i]
                return sfc_indices
            elif (sum + degree) <= controlPoint_absoluteIndex < (sum + sfc_length - degree):
                sfc_indices = [i]
                return sfc_indices
            elif (sum + sfc_length - degree) <= controlPoint_absoluteIndex < (sum + sfc_length):
                #then we return two
                sfc_indices = [i, i+1]
                return sfc_indices
        elif i == (numCorridors - 1):
            #case we are in the beginning overlap section
            if sum <= controlPoint_absoluteIndex < (sum + degree):
                sfc_indices = [i-1, i]
                return sfc_indices
            elif (sum + degree) <= controlPoint_absoluteIndex < (sum + sfc_length - degree):
                sfc_indices = [i]
                return sfc_indices
        
        #then increments by the sfc length minus the degree
        sum += (sfc_length - degree)



#arguments:
#M: the number of control points in the SFC
#N: the number of control points used in the Annulus
#d: the degree of the bspline
def getLowerIndex(numCntPts_SFC: int,
                  numCntPts_Annulus: int,
                  d: int):

    bottomIndex = int(round(numCntPts_SFC - ((numCntPts_Annulus+d)/2)))

    return bottomIndex

#gets the upper index
def getUpperIndex(numCntPts_Annulus: int,
                  d: int):
    topIndex = int(round((numCntPts_Annulus + d)/2)) - 1

    return topIndex